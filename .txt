// tests/unit/cart.service.test.ts
import { jest } from '@jest/globals';
import { Types } from 'mongoose';
import Cart from '../../src/models/Cart';
import redisClient from '../../src/config/redis';
import { withTransaction } from '../../src/utils/connectDB';
import { CartService } from '../../src/services/cart.service';
import { AddToCartRequest } from '../../src/types';

// Type-safe mocks
const mockedCart = jest.mocked(Cart);
const mockedRedis = jest.mocked(redisClient);
const mockedWithTransaction = jest.mocked(withTransaction);

describe('CartService - Unit Tests', () => {
  const userId = new Types.ObjectId().toString();
  const storeId = new Types.ObjectId().toString();
  const productId1 = new Types.ObjectId().toString();
  const productId2 = new Types.ObjectId().toString();

  const cartFactory = (overrides: Partial<ICart> = {}): ICart => ({
    _id: new Types.ObjectId(),
    userId: new Types.ObjectId(userId),
    storeId: new Types.ObjectId(storeId),
    fullName: 'Test User',
    email: 'test@example.com',
    cartItems: [],
    quantity: 0,
    totalPrice: 0,
    expireAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
    version: 1,
    createdAt: new Date(),
    updatedAt: new Date(),
    save: jest.fn().mockResolvedValue(this),
    ...overrides,
  });

  const baseRequest: AddToCartRequest = {
    productId: productId1,
    idempotencyKey: 'test-key-1',
    productTitle: 'Wireless Mouse',
    productImage: ['https://example.com/mouse.jpg'],
    productPrice: 49.99,
    productDescription: 'Ergonomic mouse',
    quantity: 2,
    fullName: 'Test User',
    email: 'test@example.com',
    storeId,
  };

  let cartService: CartService;

  beforeEach(() => {
    jest.clearAllMocks();
    cartService = new CartService();

    // Default: withTransaction executes the callback
    mockedWithTransaction.mockImplementation(async (fn) => fn({} as any));
  });

  describe('createCart', () => {
    it('creates new cart and adds item on first request', async () => {
      const newCart = cartFactory({
        cartItems: [],
        version: 1,
      });
      mockedCart.findOne.mockResolvedValue(null);
      mockedCart.mockImplementation(() => newCart as any);

      mockedRedis.set.mockResolvedValue('OK'); // idempotency lock

      const result = await cartService.createCart(userId, baseRequest);

      expect(mockedRedis.set).toHaveBeenCalledWith(
        expect.stringContaining('cart:add:'),
        '1',
        'EX',
        600,
        'NX'
      );
      expect(mockedCart.findOne).toHaveBeenCalled();
      expect((newCart as any).save).toHaveBeenCalled();
      expect(result.cartItems).toHaveLength(1);
      expect(result.cartItems[0].productQuantity).toBe(2);
      expect(result.quantity).toBe(2);
      expect(result.totalPrice).toBe(99.98);
      expect(result.version).toBe(2); // pre-save hook increments
    });

    it('blocks duplicate via idempotency key', async () => {
      mockedRedis.set.mockResolvedValue(null); // lock failed

      const result = await cartService.createCart(userId, baseRequest);

      expect(result).toBe('Cart has already been placed');
      expect(mockedCart.findOne).not.toHaveBeenCalled();
      expect(mockedWithTransaction).not.toHaveBeenCalled();
    });

    it('updates existing item when adding same product', async () => {
      const existingCart = cartFactory({
        cartItems: [{
          productId: new Types.ObjectId(productId1),
          productTitle: 'Mouse',
          productImage: ['img.jpg'],
          productPrice: 49.99,
          productQuantity: 1,
          reservedAt: new Date(),
        }],
        quantity: 1,
        totalPrice: 49.99,
        version: 5,
      });

      mockedRedis.set.mockResolvedValue('OK');
      mockedCart.findOne.mockResolvedValue(existingCart as any);

      const updatedRequest = { ...baseRequest, quantity: 3, idempotencyKey: 'new-key' };

      const result = await cartService.createCart(userId, updatedRequest);

      expect(result.cartItems).toHaveLength(1);
      expect(result.cartItems[0].productQuantity).toBe(3);
      expect(result.quantity).toBe(3);
      expect(result.totalPrice).toBe(149.97);
    });

    it('rolls back on save error', async () => {
      mockedRedis.set.mockResolvedValue('OK');
      mockedCart.findOne.mockResolvedValue(null);

      const failingCart = cartFactory();
      (failingCart as any).save.mockRejectedValue(new Error('Mongo down'));

      mockedCart.mockImplementation(() => failingCart as any);
      mockedWithTransaction.mockImplementation(async (fn) => {
        await fn({ abortTransaction: jest.fn() });
      });

      await expect(cartService.createCart(userId, baseRequest)).rejects.toThrow('Mongo down');
    });
  });

  describe('getCart', () => {
    it('serves from versioned cache when latest version matches', async () => {
      const cachedCart = cartFactory({ version: 3 });
      const latestKey = cartService['getLatestVersionKey'](userId, storeId);
      const versionKey = cartService['getCacheKey'](userId, storeId, 3);

      mockedRedis.get
        .mockResolvedValueOnce('3') // latest_version
        .mockResolvedValueOnce(JSON.stringify(cachedCart)); // versioned entry

      const result = await cartService.getCart(userId, storeId);

      expect(mockedRedis.get).toHaveBeenCalledWith(latestKey);
      expect(mockedRedis.get).toHaveBeenCalledWith(versionKey);
      expect(result).toEqual(cachedCart);
      expect(mockedCart.findOne).not.toHaveBeenCalled();
    });

    it('falls back to DB on cache miss and seeds both caches', async () => {
      const dbCart = cartFactory({ version: 4 });
      mockedRedis.get.mockResolvedValueOnce(null); // no latest_version
      mockedCart.findOne.mockResolvedValue(dbCart as any);

      const result = await cartService.getCart(userId, storeId);

      expect(result).toEqual(dbCart);
      expect(mockedRedis.set).toHaveBeenCalledTimes(2); // latest + versioned
    });

    it('returns null when no cart exists', async () => {
      mockedRedis.get.mockResolvedValueOnce(null);
      mockedCart.findOne.mockResolvedValue(null);

      const result = await cartService.getCart(userId, storeId);

      expect(result).toBeNull();
    });
  });

  describe('updateCart', () => {
    it('updates quantity and bumps version', async () => {
      const existing = cartFactory({
        cartItems: [{ productId: new Types.ObjectId(productId1), productQuantity: 1, productPrice: 100 }],
        quantity: 1,
        totalPrice: 100,
        version: 2,
      });

      const mockGetCart = jest.spyOn(cartService as any, 'getCart').mockResolvedValue(existing);

      const result = await cartService.updateCart(userId, storeId, productId1, 5);

      expect(result?.quantity).toBe(5);
      expect(result?.totalPrice).toBe(500);
      expect(result?.version).toBe(3); // incremented
      expect((existing as any).save).toHaveBeenCalled();
      mockGetCart.mockRestore();
    });
  });

  describe('deleteCart (item removal)', () => {
    it('removes item and updates totals/version', async () => {
      const existing = cartFactory({
        cartItems: [
          { productId: new Types.ObjectId(productId1), productQuantity: 2, productPrice: 50 },
          { productId: new Types.ObjectId(productId2), productQuantity: 1, productPrice: 100 },
        ],
        quantity: 3,
        totalPrice: 200,
        version: 10,
      });

      const mockGetCart = jest.spyOn(cartService as any, 'getCart').mockResolvedValue(existing);

      await cartService.deleteCart(userId, storeId, productId1);

      expect(existing.cartItems).toHaveLength(1);
      expect(existing.quantity).toBe(1);
      expect(existing.totalPrice).toBe(100);
      expect(existing.version).toBe(11);
      mockGetCart.mockRestore();
    });
  });
});



product// tests/unit/product.service.test.ts
import { jest } from '@jest/globals';
import { Types } from 'mongoose';
import Product from '../../src/models/Product';
import redisClient from '../../src/config/redis';
import { measureDatabaseQuery } from '../../src/utils/metrics';
import {
  CreateProductService,
  GetAllStoreProductService,
  GetASingleProductService,
  UpdateProductService,
  DeleteProductService,
} from '../../src/services/product.service';

// Type-safe mocks
const mockedProduct = jest.mocked(Product);
const mockedRedis = jest.mocked(redisClient);
const mockedMeasureDB = jest.mocked(measureDatabaseQuery);

describe('Product Service - Unit Tests', () => {
  const userId = new Types.ObjectId().toString();
  const storeId = new Types.ObjectId().toString();
  const productId = new Types.ObjectId().toString();

  const productFactory = (overrides: Partial<IProduct> = {}): IProduct => ({
    _id: new Types.ObjectId(productId),
    user: new Types.ObjectId(userId),
    store: new Types.ObjectId(storeId),
    name: 'Premium Headphones',
    price: 199.99,
    images: ['https://example.com/headphone.jpg'],
    description: 'High quality wireless headphones',
    isArchive: false,
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  });

  const createInput = {
    name: 'Premium Headphones',
    price: 199.99,
    images: ['https://example.com/headphone.jpg'],
    description: 'High quality wireless headphones',
  };

  beforeEach(() => {
    jest.clearAllMocks();
    // Default: measureDatabaseQuery passes through
    mockedMeasureDB.mockImplementation(async (_name, fn) => fn());
  });

  describe('CreateProductService', () => {
    it('creates a new product with correct ownership', async () => {
      const expectedProduct = productFactory();
      mockedProduct.create.mockResolvedValue(expectedProduct);

      const result = await CreateProductService(userId, storeId, createInput);

      expect(mockedProduct.create).toHaveBeenCalledWith({
        user: new Types.ObjectId(userId),
        store: new Types.ObjectId(storeId),
        ...createInput,
      });
      expect(result).toEqual(expectedProduct);
    });

    it('propagates database errors', async () => {
      mockedProduct.create.mockRejectedValue(new Error('Mongo timeout'));

      await expect(CreateProductService(userId, storeId, createInput))
        .rejects.toThrow('Mongo timeout');
    });
  });

  describe('GetAllStoreProductService', () => {
    const query = { store: storeId };
    const skip = 0;
    const limit = 20;

    it('returns cached results when available', async () => {
      const cached = [productFactory(), productFactory({ name: 'Mouse' })];
      const cacheKey = `product:search:${JSON.stringify({ query, skip, limit })}`;
      mockedRedis.get.mockResolvedValue(JSON.stringify(cached));

      const result = await GetAllStoreProductService(query, skip, limit);

      expect(mockedRedis.get).toHaveBeenCalledWith(cacheKey);
      expect(result).toEqual(cached);
      expect(mockedProduct.find).not.toHaveBeenCalled();
    });

    it('fetches from DB on cache miss and caches result', async () => {
      const products = [productFactory()];
      const cacheKey = `product:search:${JSON.stringify({ query, skip, limit })}`;

      const mockChain = {
        skip: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        sort: jest.fn().mockReturnThis(),
        lean: jest.fn().mockResolvedValue(products),
        exec: jest.fn(),
      };

      mockedRedis.get.mockResolvedValue(null);
      mockedProduct.find.mockReturnValue(mockChain as any);

      const result = await GetAllStoreProductService(query, skip, limit);

      expect(mockedProduct.find).toHaveBeenCalledWith(query);
      expect(mockChain.skip).toHaveBeenCalledWith(skip);
      expect(mockChain.limit).toHaveBeenCalledWith(limit);
      expect(mockChain.sort).toHaveBeenCalledWith({ createdAt: -1 });
      expect(mockChain.lean).toHaveBeenCalled();
      expect(mockedRedis.set).toHaveBeenCalledWith(cacheKey, JSON.stringify(products), 'EX', expect.any(Number));
      expect(result).toEqual(products);
    });

    it('caches empty results to prevent DB thrashing', async () => {
      mockedRedis.get.mockResolvedValue(null);
      mockedProduct.find.mockReturnValue({
        skip: () => ({ limit: () => ({ sort: () => ({ lean: () => Promise.resolve([]) }) }) }),
      } as any);

      const result = await GetAllStoreProductService({ name: 'nonexistent' }, 0, 10);

      expect(result).toEqual([]);
      expect(mockedRedis.set).toHaveBeenCalled();
    });
  });

  describe('GetASingleProductService', () => {
    const cacheKey = `product:${productId}`;

    it('serves from cache when present', async () => {
      const cachedProduct = productFactory();
      mockedRedis.get.mockResolvedValue(JSON.stringify(cachedProduct));

      const result = await GetASingleProductService(productId);

      expect(mockedRedis.get).toHaveBeenCalledWith(cacheKey);
      expect(result).toEqual(cachedProduct);
      expect(mockedProduct.findById).not.toHaveBeenCalled();
    });

    it('fetches and caches on miss', async () => {
      const dbProduct = productFactory();
      mockedRedis.get.mockResolvedValue(null);
      mockedProduct.findById.mockResolvedValue(dbProduct);

      const result = await GetASingleProductService(productId);

      expect(mockedProduct.findById).toHaveBeenCalledWith(productId);
      expect(mockedRedis.set).toHaveBeenCalledWith(cacheKey, expect.any(String), 'EX', expect.any(Number));
      expect(result).toEqual(dbProduct);
    });

    it('returns null for non-existent product without caching', async () => {
      mockedRedis.get.mockResolvedValue(null);
      mockedProduct.findById.mockResolvedValue(null);

      const result = await GetASingleProductService(productId);

      expect(result).toBeNull();
      expect(mockedRedis.set).not.toHaveBeenCalled(); // negative caching optional
    });
  });

  describe('UpdateProductService', () => {
    const updates = { price: 299.99, name: 'Upgraded Headphones' };
    const updatedProduct = productFactory(updates);

    it('updates and returns new version', async () => {
      mockedProduct.findByIdAndUpdate.mockResolvedValue(updatedProduct);

      const result = await UpdateProductService(productId, updates);

      expect(mockedProduct.findByIdAndUpdate).toHaveBeenCalledWith(
        productId,
        { $set: updates },
        { new: true, runValidators: true }
      );
      expect(result).toEqual(updatedProduct);
      expect(result?.price).toBe(299.99);
    });

    it('returns null when product not found', async () => {
      mockedProduct.findByIdAndUpdate.mockResolvedValue(null);

      const result = await UpdateProductService(productId, updates);

      expect(result).toBeNull();
    });
  });

  describe('DeleteProductService', () => {
    const cacheKey = `product:${productId}`;

    it('deletes product and invalidates cache', async () => {
      const existing = productFactory();
      mockedProduct.findByIdAndDelete.mockResolvedValue(existing);

      const result = await DeleteProductService(productId);

      expect(mockedProduct.findByIdAndDelete).toHaveBeenCalledWith(productId);
      expect(mockedRedis.del).toHaveBeenCalledWith(cacheKey);
      expect(result).toBe('Product has been deleted');
    });

    it('handles non-existent product gracefully', async () => {
      mockedProduct.findByIdAndDelete.mockResolvedValue(null);

      const result = await DeleteProductService(productId);

      expect(mockedRedis.del).toHaveBeenCalledWith(cacheKey); // still clear stale cache
      expect(result).toBe('Product has been deleted');
    });
  });
});






INTEGRATION TESRD
// tests/integration/cart.controller.test.ts
import request from 'supertest';
import { app } from '../../src/app'; // your express app
import mongoose from 'mongoose';
import Cart from '../../src/models/Cart';
import { AuthenticatedRequest } from '../../src/types';

const mockUser = {
  userId: new mongoose.Types.ObjectId().toString(),
  name: 'Test User',
};

const mockAuthMiddleware = jest.fn((req: any, _res: any, next: any) => {
  (req as AuthenticatedRequest).user = mockUser;
  next();
});

jest.mock('../../src/middleware/auth.middleware', () => ({
  authenticate: mockAuthMiddleware,
}));

describe('Cart Controller Integration Tests', () => {
  let storeId: string;
  let productId1: string;
  let productId2: string;

  beforeAll(async () => {
    storeId = new mongoose.Types.ObjectId().toString();
    productId1 = new mongoose.Types.ObjectId().toString();
    productId2 = new mongoose.Types.ObjectId().toString();
  });

  afterEach(async () => {
    await Cart.deleteMany({});
  });

  describe('POST /:storeId/store - Add to Cart', () => {
    it('creates new cart and adds item', async () => {
      const res = await request(app)
        .post(`/api/v1/carts/${storeId}/store`)
        .send({
          productId: productId1,
          productTitle: 'Headphones',
          productImage: 'https://example.com/img.jpg',
          productPrice: 99.99,
          quantity: 2,
          idempotencyKey: 'test-1',
        });

      expect(res.status).toBe(201);
      expect(res.body.cartItems).toHaveLength(1);
      expect(res.body.cartItems[0].productQuantity).toBe(2);
      expect(res.body.quantity).toBe(2);
      expect(res.body.totalPrice).toBe(199.98);
    });

    it('is idempotent - duplicate request returns message', async () => {
      const payload = {
        productId: productId1,
        productTitle: 'Headphones',
        productImage: 'https://example.com/img.jpg',
        productPrice: 99.99,
        quantity: 1,
        idempotencyKey: 'dup-1',
      };

      const first = await request(app)
        .post(`/api/v1/carts/${storeId}/store`)
        .send(payload);
      expect(first.status).toBe(201);

      const second = await request(app)
        .post(`/api/v1/carts/${storeId}/store`)
        .send(payload);
      expect(second.status).toBe(200);
      expect(second.body.message).toBe('Cart has already been placed');
    });

    it('updates existing item quantity when adding same product', async () => {
      await request(app)
        .post(`/api/v1/carts/${storeId}/store`)
        .send({
          productId: productId1,
          productTitle: 'Headphones',
          productPrice: 50,
          quantity: 1,
          idempotencyKey: 'add-1',
        });

      await request(app)
        .post(`/api/v1/carts/${storeId}/store`)
        .send({
          productId: productId1,
          productTitle: 'Headphones',
          productPrice: 50,
          quantity: 3,
          idempotencyKey: 'add-2',
        });

      const res = await request(app).get(`/api/v1/carts/${storeId}/store`);
      expect(res.body.cartItems[0].productQuantity).toBe(3);
    });
  });

  describe('GET /:storeId/store - Get User Cart', () => {
    it('returns fresh cart immediately after add (cache test)', async () => {
      await request(app)
        .post(`/api/v1/carts/${storeId}/store`)
        .send({
          productId: productId1,
          productTitle: 'Mouse',
          productPrice: 25,
          quantity: 4,
          idempotencyKey: 'fresh-1',
        });

      const res = await request(app).get(`/api/v1/carts/${storeId}/store`);
      expect(res.status).toBe(200);
      expect(res.body.quantity).toBe(4);
      expect(res.body.totalPrice).toBe(100);
    });

    it('returns 404 for empty cart', async () => {
      const res = await request(app).get(`/api/v1/carts/${storeId}/store`);
      expect(res.status).toBe(404);
    });
  });

  describe('PUT /:storeId/store - Update Item', () => {
    it('updates quantity successfully', async () => {
      await request(app)
        .post(`/api/v1/carts/${storeId}/store`)
        .send({
          productId: productId1,
          productTitle: 'Keyboard',
          productPrice: 100,
          quantity: 1,
          idempotencyKey: 'setup-update',
        });

      const res = await request(app)
        .put(`/api/v1/carts/${storeId}/store`)
        .send({ productId: productId1, quantity: 5 });

      expect(res.status).toBe(200);
      expect(res.body.quantity).toBe(5);
      expect(res.body.totalPrice).toBe(500);
    });
  });

  describe('DELETE /:storeId/store - Remove Item', () => {
    it('removes item and updates totals', async () => {
      await request(app)
        .post(`/api/v1/carts/${storeId}/store`)
        .send({
          productId: productId1,
          productTitle: 'A',
          productPrice: 10,
          quantity: 2,
          idempotencyKey: 'del-1',
        });

      await request(app)
        .post(`/api/v1/carts/${storeId}/store`)
        .send({
          productId: productId2,
          productTitle: 'B',
          productPrice: 20,
          quantity: 1,
          idempotencyKey: 'del-2',
        });

      await request(app)
        .delete(`/api/v1/carts/${storeId}/store`)
        .send({ productId: productId1 });

      const res = await request(app).get(`/api/v1/carts/${storeId}/store`);
      expect(res.body.cartItems).toHaveLength(1);
      expect(res.body.cartItems[0].productId).toBe(productId2);
      expect(res.body.totalPrice).toBe(20);
    });
  });
});






/// GRAFANA
1. AVAILABILITY
100 * (1 - (sum(increase(user_http_request_total{success="false"}[28d])) / sum(increase(user_http_request_total[28d]))))

2. ERROR BUDGET
100 * (1 - (sum(increase(user_http_request_total{success="false"}[28d])) / (sum(increase(user_http_request_total[28d])) * (1 - 0.999))))

3. LATENCY, SLO: P99

histogram_quantile(0.95, sum(rate(user_http_request_duration_seconds_bucket[5m])) by (le))

